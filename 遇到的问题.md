# 遇到的问题

## 1.获取bean找不到

在构建service层时，测试事务是否生效的时候使用以下代码：

```java
  @org.junit.Test
    public void testService(){
        ApplicationContext a = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserService bean = a.getBean(UserServiceImpl.class);
        User user = new User(CreateId.getUUID(),"name",10,"男","111","111");
        bean.addUser(user);
    }
```

被测试代码：

```java
@Service
@Transactional
public class UserServiceImpl implements UserService {

    @Resource
    UserMapper userMapper;

    @Override
    public int addUser(User user) {
        user.setName("true");
        userMapper.addUser(user);
        int i = 10 / 0;
        user.setName("false");
        userMapper.addUser(user);
        return 0;
    }
    
}
```

遇到以下问题：

```java
org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type 'com.fourteen.service.impl.UserServiceImpl' available
```

此时应该为：

```java
@org.junit.Test
    public void testService(){
        ApplicationContext a = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserService bean = a.getBean(UserService.class);
        User user = new User(CreateId.getUUID(),"name",10,"男","111","111");
        bean.addUser(user);
    }
```

获取的对象应该为接口而不是实现类对象

因为@Service虽然会实现对象但是@Transactional也会实现一个代理对象并且替代之前已经生成的对象，所以

```java
        UserService bean = a.getBean(UserServiceImpl.class);
```

才会找不到对象

具体分析：

测试代码（在UserServiceImpl类上没有添加@Transactional）：

```java
    @org.junit.Test
    public void testService(){
        ApplicationContext a = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserService bean = a.getBean(UserService.class);
        Object userService = a.getBean("userServiceImpl");
        
        System.out.println(bean);
        System.out.println(userService);

    }
```

结果：

```java
class com.fourteen.service.impl.UserServiceImpl
class com.fourteen.service.impl.UserServiceImpl
```

UserServiceImpl类上添加@Transactional：

```java
class com.sun.proxy.$Proxy22
class com.sun.proxy.$Proxy22
```

由分析可知有以下关系：UserServiceImpl实现了UserService，但因为开启了事务管理，所以事务管理生成了一个新的代理对象代替了之前UserServiceImpl在spring容器中的位置，而这个时候UserServiceImpl和com.sun.proxy是平级的，所以不能根据UserServiceImpl.class获取而是可以根据其名字userServiceImpl获得对象。

<img src="notes_img\1.png" style="zoom:67%;" />





## 声明：所有分析和理解都是个人意见，如有不同意见请勿喷~

